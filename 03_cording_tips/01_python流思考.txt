・pythonには、CPython, Jython, IronPython, PyPyなど複数のランタイムがある。

/********/
/* 空白 */
/********/
・構文上意味を持つレベルのインデントには、４つの空白をつかう
・ファイルでは、関数とクラスは２行の空白行で分ける
・リストの添字、関数呼び出し、キーワード引数代入では、前後に空白をおかない
・変数代入の前後には、空白を必ず一つだけおく

/************/
/* 名前つけ */
/************/
・関数、変数、属性は、lowercase_underscoreのように小文字で下線を挟む
・プロテクテッド属性は、_leading_undersocoreのように下線を先頭に１つつける
・プライベート属性は、__double_undersocoreのように下線を先頭に2つつける
・クラスと例外は、CapitalizeWordのように先頭を大文字にする
・モジュールレベルの定数は、ALL_CAPSのように大文字で下線を挟む
・クラスのインスタンスメソッドは（オブジェクトを参照する）第一仮引数の名前にselfを使う
・クラスメソッドは（クラスを参照する）第一仮引数の名前にclsを使う

/**********/
/* 式と文 */
/**********/
・if not (a is b) ではなく if a is not b を使う
・if len(list) == 0 や、list == [] がどうかをチェックしないで、if not listを使う
→listが空だとfalseとなり、値が入っているとtrueになる。
・１行のif文、forとwhileのループ、except複合文を書かない。明確さのために複数行にする
・インポートする時は、常にモジュールの絶対名を使い、現モジュールのパスからの相対名を使わない
→例えば、モジュールfooをパッケージbarからインポートする時は、import fooではなくfrom bar import fooを使う
・インポートの順序
→標準ライブラリ→サードパーティーのモジュール→自分のモジュール。各部分ではアルファベット準にインポートする （サードパーティモジュールとは、公式にはサポートされていない、 第三者の組織で開発がされているモジュールです。） 


/************************/
/* python３の文字の表し方 */
/************************/
bytes と str がある。
・bytesのインスタンスは、生の８ビット値を含む
・strのインスタンスは、Unicode文字を含む


/******************************************/
/* 複雑の関数の変わりにヘルパー関数を使う */
/******************************************/
ヘルパー関数とは、複雑なロジックや、よく使う機能をまとめた関数のことで
通常の関数と考えて良い。
・ヘルパー関数を使うことによって、コードが読みやすくなり扱いやすくなり、デバックが速くなる


/******************************************************/
/* シーケンスをどのようにスライスされるかを知っておく */
/******************************************************/
スライス演算は、list, str, bytesという組み込み型で利用できる。
また、__getitem__, __setitem__ を実装しているクラスにも利用できる
文法は、list[start:end] でstartの要素は含み、endの要素は含まない
list   =      ['a','b','c','d','e','f','g','h']
list[:]     # ['a','b','c','d','e','f','g','h']
list[:5]    # ['a','b','c','d','e']
list[:-1]   # ['a','b','c','d','e','f','g']
list[4:]    #                 ['e','f','g','h']
list[-3:]   #                     ['f','g','h']
list[2:5]   #         ['c','d','e']
list[2:-1]  #         ['c','d','e','f','g']
list[-3:-1] #                     ['f','g']
・startに０を指定したり、endに列長を指定したりしない
また、list[100]は範囲外参照になるがlist[:100]は範囲外参照にならない



/****************************************************/
/* 一つのスライスでは、start, end, strideを使わない */
/****************************************************/
またスライスの機能には、
list[start:end:stride]という形式でスライスの増分（stride）を規定する構文がある。
b=[2:-1:2] というように、いっぺんに指定しない。
b=[::2]
c=b[1:-1]
といった書き方をする。


/***************************************/
/* mapやfilterの変わりに内包表記を使う */
/***************************************/
map()とは、全ての要素に関数を適用する
x = (1, 4, 3, 5, 2)
y = list(map(lambda i: i*10, x))
y # [10, 40, 30, 50, 20]

filter()とは、イテラブルの要素を絞り込む
x = (1, 4, 3, 5, 2)
y = list(filter(lambda i: i>3, x)
y # [4, 5]

・mapやfilterよりリストの内包表現のが読みやすいから簡単な処理の場合は、リストの内包表現を使う
a = [1, 2, 3, 4, 5]
b = [x**2 for x in a]
のほうが
b = [lambda x: x**2 , a)
よりわかりやすい


/*******************************************/
/* リスト内包表記には、3つ以上の式を避ける */
/*******************************************/
リスト内包表記は、複数レベルのループと、1つのループに複数の条件をサポートする
・リストの内包表現のが読みやすいからといってあまり複雑な処理はしないようにする
素直に複数のfor文にする

matrix = [[1,2,3],[4,5,6],[7,8,9]]
filtered = [[x for in row if x % 3 == 0] for row in matrix if sum(row) >= 10]
filtered # [[6],[9]]

/**********************************************/
/* 大きな内包表記には、ジェネレータ式を考える */
/**********************************************/
内包表記は一度の処理をしてメモリに展開してしまうから、扱うデータのサイズが大きいとOut of Memoryになる危険性があるので、generator式を使う
ジェネレータとは、メモリ効率の良いイテラブルのオブジェクト
ジェネレーター式とは、実行時には出力シーケンス全体を実際に生成することはない。
その変わりに、ジェネレータ式の評価値は、イテレータで式から1つずつ要素をyieldで出す
yieldは、関数を一時的に実行停止させることが出来る機能を持つ文です。
return文でそのまま値を返す関数を作ったとします。
一度に大きなリストが返ってくるような関数だと、たくさんのメモリを一度に消費してしまうことになります。そのようなときは、yieldを使う事でその莫大な量の戻り値を小分けにして返すことが出来ます。これによって関数の実行をその都度中断し、少量ずつデータを返す事でメモリの消費量を抑えることが出来るようになります。
また、ステートフルなので注意が必要
def myfunc():
    yield 'one'
    yield 'two'
    yield 'three'

x = myfunc()
y = myfunc()

print(x.__next__())  # one  
print(x.__next__())  # two  
print(x.__next__())  # three
print(next(y)) # one  
print(next(y)) # two  
print(next(y)) # three


ジェネレータ式は、リスト内包表記と同じ構文だが、周囲を（）でくくる構文。
例えば、
value = [len(x) for x in open('my_file.txt')]
value # [100, 57, 15, 1, 12, 75, 5, 86, 89, 11]
を
it = (len(x) for x in open('my_file.txt'))
it # <generator object <genexpr> at 0x101b81245>
のようになる
itの値をみるためには、next(it)のようにする

・ジェネレータを連鎖的に組み合わせると非常に高速に動作する


/******************************/
/* rangeよりはenumerateにする */
/******************************/
for i in range(len(num_list)):
    num = num_list[i]
    print('%d: %s' %(i+1,num))

より、

for i, num range enumerate(num_list):
    print('%d: %s' %(i+1,num))
    
にした方が読みやすい
ちなみに、range(5) 0,1,2,3,4


/*******************************************/
/* イテレータを並列に処理するにはzipを使う */
/*******************************************/
zipは、複数のイテレータを並列に処理するのに使える
names = ['a','bb','ccc','ddddd']
letters = [len(n) for n in names]
longest_name = None
max_letters = 0

for i, name in enumerate(names):
    count = letters[i]
    if count > max_letters:
        longest_name = name
        max_letters = count

print(max_letters)  # 5

をzipを使うと

names = ['a','bb','ccc','ddddd']
letters = [len(n) for n in names]
longest_name = None
max_letters = 0

for name, count in zip(names, letters):
    if count > max_letters:
        longest_name = name
        max_letters = count

print(max_letters)  # 5
となる。

※異なる長さのイテレータを与えると、zip()は最短の出力で止める
組み込みモジュールのitertoolsのzip_longest()を使えばイテレータの長さが異なる時に使える


/********************************************************/
/* forとwhileループのあとのelseブロックは使うのを避ける */
/********************************************************/
forとwhileループのあとのelseブロックの直後にelseブロックを許す特別な構文があるが、誤解を生みやすいので使わない
ちなみに、

for i in range(3):
    print('Loop %d' %i)
    if i==1:
        break
else:
    print('Else block!')
# Loop 0
# Loop 1

for文が最後まで実行されたらelseブロックを実行する。
